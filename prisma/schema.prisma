// =================================================================
// Prisma Schema Configuration
// =================================================================

generator client {
   provider = "prisma-client-js"
}

datasource db {
   provider = "postgresql"
   url      = env("PG_DATABASE_URL")
}

/**
 * ### Configuration Details:
 * - The `prisma-client-js` generator creates the Prisma Client for database access.
 * - The `db` datasource connects to a PostgreSQL database, with the connection URL sourced from the environment variable `PG_DATABASE_URL`.
 */

// =================================================================
// Queue Management Documentation
// =================================================================

/**
 * Queue System Setup and Maintenance
 * -----------------------------------
 * ### Initial Setup:
 * 1. Run `npx prisma generate` to update Prisma Client with the Queue model.
 * 2. Run `npx prisma migrate dev --name add_queue_system` to create the initial queue table.
 * ### Making Schema Changes:
 * 1. Update the schema in this file.
 * 2. Run `npx prisma generate` to update the client.
 * 3. Run `npx prisma migrate dev --name describe_your_change` to apply changes.
 * ### Development Tools:
 * - Use `npx prisma studio` to view and manage queue data.
 * - Use `npx prisma migrate reset` to reset the database during development.
 * ### Queue Status Types:
 * - "waiting": Request is in the queue.
 * - "processing": Request is currently being handled.
 * - "completed": Request has been fulfilled.
 * - "cancelled": Request has been cancelled.
 * ### Service Types:
 * - "trueCopy": Request for document copies.
 * - "verify": Account verification request.
 * ### Important Notes:
 * - Queue numbers auto-increment.
 * - Timestamps are automatically generated.
 * - User relation is optional.
 * - The `documents` field stores an array of document types.
 */

// =================================================================
// Authentication Models
// =================================================================

enum UserRole {
   ADMIN
   STAFF
   USER
}

/**
 * ### UserRole Enum:
 * Defines the roles available for users in the system:
 * - `ADMIN`: Has full permissions.
 * - `STAFF`: Has limited administrative permissions.
 * - `USER`: Standard user role.
 */

enum QueueStatus {
   WAITING
   PROCESSING
   COMPLETED
   CANCELLED
}

/**
 * ### QueueStatus Enum:
 * Represents the current status of a queue request:
 * - `WAITING`: The request is in the queue and not yet processed.
 * - `PROCESSING`: The request is currently being handled.
 * - `COMPLETED`: The request has been fulfilled.
 * - `CANCELLED`: The request was cancelled by the user or staff.
 */

enum ServiceType {
   TRUE_COPY
   VERIFY
}

/**
 * ### ServiceType Enum:
 * Defines the types of services available in the queue system:
 * - `TRUE_COPY`: Request for document copies.
 * - `VERIFY`: Account verification request.
 */

enum Permission {
   QUEUE_VIEW
   QUEUE_PROCESS
   QUEUE_DELETE
   QUEUE_UPDATE
   QUEUE_ADD_NOTES
   USERS_MANAGE
}

/**
 * ### Permission Enum:
 * Lists the specific permissions for users in the system:
 * - `QUEUE_VIEW`: Allows viewing of queue items.
 * - `QUEUE_PROCESS`: Allows processing queue requests.
 * - `QUEUE_DELETE`: Allows deletion of queue items.
 * - `QUEUE_UPDATE`: Allows updating of queue details.
 * - `QUEUE_ADD_NOTES`: Allows adding notes to queue items.
 * - `USERS_MANAGE`: Allows managing user accounts and roles.
 */

model User {
   id            String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
   email         String       @unique
   name          String
   emailVerified Boolean
   image         String?
   username      String?      @unique
   role          UserRole     @default(ADMIN)
   permissions   Permission[]
   createdAt     DateTime
   updatedAt     DateTime

   // Relations
   sessions    Session[]
   accounts    Account[]
   queues      Queue[]
   profile     Profile?
   attachments Attachment[]

   @@map("user")
}

/**
 * ### User Model:
 * Represents system users and their attributes:
 * - Has fields for `id`, `email`, `name`, `role`, and permissions.
 * - Supports relations to sessions, accounts, and queues.
 */

model Session {
   id        String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
   expiresAt DateTime
   token     String   @unique
   createdAt DateTime
   updatedAt DateTime
   ipAddress String?
   userAgent String?
   userId    String   @db.Uuid
   user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

   @@map("session")
}

/**
 * ### Session Model:
 * Stores user sessions, including `token`, expiration, and device details:
 * - Links to a user via the `userId` field.
 * - Automatically deletes sessions if the linked user is removed.
 */

model Account {
   id                    String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
   accountId             String
   providerId            String
   userId                String    @db.Uuid
   user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
   password              String?
   accessToken           String?
   refreshToken          String?
   idToken               String?
   accessTokenExpiresAt  DateTime?
   refreshTokenExpiresAt DateTime?
   scope                 String?
   createdAt             DateTime
   updatedAt             DateTime

   @@map("account")
}

/**
 * ### Account Model:
 * Represents external accounts linked to users:
 * - Includes fields for tokens, provider details, and expiration times.
 * - Supports cascading deletions when linked users are removed.
 */

model Verification {
   id         String    @id
   identifier String
   value      String
   expiresAt  DateTime
   createdAt  DateTime?
   updatedAt  DateTime?

   @@map("verification")
}

/**
 * ### Verification Model:
 * Handles verification tokens for user-related operations:
 * - Includes `identifier`, `value`, and expiration time.
 * - Primarily used for email or password verification processes.
 */

// =================================================================
// CRIS Custom Tables
// =================================================================

model Queue {
   id              String      @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
   ticketNumber    Int         @unique @default(autoincrement())
   kioskNumber     Int?
   status          QueueStatus @default(WAITING)
   serviceType     ServiceType
   userId          String?     @db.Uuid
   email           String?
   documents       String[]
   processingNotes String?
   createdAt       DateTime    @default(now())
   updatedAt       DateTime    @updatedAt
   completedAt     DateTime?

   // Relations
   user User? @relation(fields: [userId], references: [id])

   @@map("queue")
}

enum AttachmentType {
   BIRTH_CERTIFICATE
   DEATH_CERTIFICATE
   MARRIAGE_CERTIFICATE
}

model Profile {
   id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
   userId      String    @unique @db.Uuid
   dateOfBirth DateTime?
   phoneNumber String?
   address     String?
   city        String?
   state       String?
   country     String?
   postalCode  String?
   bio         String?   @db.Text
   occupation  String?
   gender      String?
   nationality String?
   createdAt   DateTime  @default(now())
   updatedAt   DateTime  @updatedAt

   // Relation to User
   user User @relation(fields: [userId], references: [id], onDelete: Cascade)

   @@map("profile")
}

model Attachment {
   id         String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
   userId     String         @db.Uuid
   type       AttachmentType @default(BIRTH_CERTIFICATE)
   fileUrl    String
   fileName   String
   fileSize   Int
   mimeType   String
   status     String         @default("pending") // pending, verified, rejected
   uploadedAt DateTime       @default(now())
   updatedAt  DateTime       @updatedAt
   verifiedAt DateTime?
   notes      String?        @db.Text

   // Relation to User
   user User @relation(fields: [userId], references: [id], onDelete: Cascade)

   @@map("attachment")
}

/**
 * ### Queue Model:
 * Represents the queue system:
 * - Stores queue-specific attributes such as `ticketNumber`, `status`, and `serviceType`.
 * - Includes optional relations to a user for tracking requests.
 * - Automatically tracks timestamps (`createdAt`, `updatedAt`).
 */

// =================================================================
// Prisma CLI Commands Reference
// =================================================================

/**
 * ### Initial Setup:
 * - `prisma init`: Initialize a new Prisma project.
 * - `npx prisma generate`: Generate Prisma Client.
 * - `npx @better-auth/cli init`: Initialize Better Auth (requires `pnpm add @better-auth/cli`).
 * ### Database Operations:
 * - `npx prisma db push`: Push schema changes directly to the database.
 * - `npx prisma migrate dev`: Create a new migration and apply it.
 * - `npx prisma migrate reset`: Reset the database to the initial state.
 * - `npx prisma db seed`: Run database seeding.
 * - `npx @better-auth/cli migrate`: Run Better Auth migrations.
 * ### Development Tools:
 * - `npx prisma studio`: Open Prisma Studio (database GUI).
 * ### Common Workflows:
 * 1. **Making schema changes**:
 * - Update `schema.prisma`.
 * - Run `npx prisma generate`.
 * - Run `npx prisma db push` (development) or `npx prisma migrate dev` (production).
 * 2. **Resetting the database**:
 * - Run `npx prisma migrate reset`.
 * - Run `npx prisma db seed` (if needed).
 * 3. **Viewing data**:
 * - Run `npx prisma studio`.
 */
